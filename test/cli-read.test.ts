[{"bun:test": "import { mkdirSync", "fs": "import { join"}, {"os": "import { serializeMemoryMarkdown"}, {"../src/id.js": "import type { MemoryEntryMeta"}, {"code": "number;\n  constructor(code: number) {\n    super(`process.exit(${code"}, {"testDir": "string;\n  let exitSpy: ReturnType<typeof spyOn>;\n  let logSpy: ReturnType<typeof spyOn>;\n  let errorSpy: ReturnType<typeof spyOn>;\n\n  beforeEach(async () => {\n    testDir = join(tmpdir()", "recursive": true}, {"log": ".", "error": ".", "recursive": true, "force": true}, {"fullMeta": "MemoryEntryMeta = {\n      id", "status": "captured", "used": 0, "last_used": "new Date().toISOString()", "pinned": false, "createdAt": "now", "updatedAt": "now", "-": ""}, {"stdout": "async () => {\n    const { run"}, ["id]);\n\n    expect(logSpy).toHaveBeenCalled();\n    const calls = logSpy.mock.calls.flat().join(\"\n\");\n    expect(calls).toContain(`id: ${id}`);\n    expect(calls).toContain(\"title: Test Entry\");\n    expect(calls).toContain(\"This is the body content.\");\n  });\n\n  test(\"prints tags when present", "async () => {\n    const { run } = await import(\"../src/cli/read.js\");\n    process.env.MEMORY_ROOT = testDir;\n\n    const id = await createEntry(\"Tagged Entry", "body", {"tags": ["topic__xstate", "area__testing"]}, "await run([id]);\n\n    const calls = logSpy.mock.calls.flat().join(\"\n\");\n    expect(calls).toContain(", ["topic__xstate, area__testing]\");\n  });\n\n  test(\"requires id argument", "async () => {\n    const { run } = await import(\"../src/cli/read.js", "process.env.MEMORY_ROOT = testDir;\n\n    expect(async () => {\n      await run([]);\n    }).toThrow(new ExitError(1));\n    expect(errorSpy).toHaveBeenCalledWith(\"usage: memory read <id>\");\n  });\n\n  test(\"exits with code 1 if entry not found", "async () => {\n    const { run } = await import(\"../src/cli/read.js\");\n    process.env.MEMORY_ROOT = testDir;\n\n    expect(async () => {\n      await run([\"id__NOTFND"]], {"body\");\n    await run([id]);\n\n    const calls = logSpy.mock.calls.flat().join(\"\n\");\n    expect(calls).toContain(": "sed: 1", "reads": "async () => {\n    const { run"}, ["id]);\n    expect(logSpy.mock.calls.flat().join(\"\n\")).toContain(\"used: 1", "logSpy.mockClear();\n\n    await run([id]);\n    expect(logSpy.mock.calls.flat().join(\"\n\")).toContain(\"used: 2"]]